[{"title":"在其他电脑修改已经创建好的 hexo 项目","date":"2018-01-13T13:30:12.140Z","path":"2018/01/13/hexo_git/","text":"添加 ssh key 到 github 上获取 ssh key两种方式： Git Bash 1$ cat ~/.ssh/id_rsa.pub 将内容复制 git GUI Help-&gt;Show SSH Key-&gt;Copy To Clipboard 添加到 githubsetting-&gt; ssh and gpg-&gt; add ssh key 。title 里随便填个设备名，下面的输入框粘贴我们刚刚复制的内容。最后点击 add ssh key 即可添加成功。 克隆仓库到本地打开 git bash，先把你的项目克隆到本地，两种克隆方式： HTTPS ：每次提交的时候要输入用户名和密码。 SSH ：添加了 ssh key 到 github 上的话，就不用输入用户名和密码。 点击右边的小按钮复制链接。然后在 git bash 中输入如下命令： 1$ git clone git@github.com:kinglion580/kinglion580.github.io.git 这样就把仓库克隆下来了。 除了 clone ，也可以直接到 releases 中去下载需要的版本，然后解压也是可以 安装 hexo首先进入克隆下来的仓库的目录下 1$ cd kinglion580.github.io 然后执行： 123$ hexo helpERROR Local hexo not found in E:\\github\\kinglion580.github.ioERROR Try running: 'npm install hexo --save' 这个时候是会报错的。我们需要安装 hexo 1$ npm install hexo --save 再运行 hexo help 可以看到如下信息： 12345678910111213141516171819202122232425262728$ hexo helpUsage: hexo &lt;command&gt;Commands: clean Remove generated files and cache. config Get or set configurations. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. list List the information of the site migrate Migrate your site from other system to Hexo. new Create a new post. publish Moves a draft post from _drafts to _posts folder. render Render files with renderer plugins. server Start the server. version Display version information.Global Options: --config Specify config file instead of using _config.yml --cwd Specify the CWD --debug Display all verbose messages in the terminal --draft Display draft posts --safe Disable all plugins and scripts --silent Hide output on consoleFor more help, you can use 'hexo help [command]' for the detailed informationor you can check the docs: http://hexo.io/docs/ 安装依赖的插件在 package.json 文件中保存了 hexo 的版本和依赖的软件： 执行 npm install 的时候自动将需要的这些软件都安装上了。 执行 hexo s 后，在浏览器输入地址 localhost:4000 就可以看到博客了。 除了修改了系统主配置文件 _config.yml 需要重新生成启动外，修改其他的文件直接刷新浏览器就可以看到效果。 关于推送首先将源码推送到 github 上（source 分支），然后再使用 hexo 的命令生成且推送到 master 分支上。 在仓库根目录下： $ 左边是代表分支，不用输入，只输$ 右边 123source$ git add .source$ git commit -m 'your descri'source$ git push origin source 将 hexo 生成内容推送到 master 分支： 12$ hexo clean$ hexo g -d hexo 默认就是推送到 master 分支上，这个配置在系统主配置文件 _config.yml 中： deploy 配置项，想更改分支直接修改 branch 值。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://kinglion580.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://kinglion580.github.io/tags/git/"},{"name":"deploy","slug":"deploy","permalink":"http://kinglion580.github.io/tags/deploy/"},{"name":"branch","slug":"branch","permalink":"http://kinglion580.github.io/tags/branch/"}]},{"title":"添加评论","date":"2018-01-13T13:21:55.385Z","path":"2018/01/13/comment/","text":"gitment待补 valine valine github valine 说明文档 valine 基于 leancloud ，先要注册一个 leancloud 账号 点击这里注册 然后 创建应用 选择刚刚创建的应用&gt;设置&gt;选择应用 Key 在安全中心配置安全域名 https://kinglion580.github.io 修改系统配置文件 _config.yml 的配置 valine ，具体配置参见 https://valine.js.org/#/configuration","tags":[{"name":"hexo","slug":"hexo","permalink":"http://kinglion580.github.io/tags/hexo/"},{"name":"comment","slug":"comment","permalink":"http://kinglion580.github.io/tags/comment/"},{"name":"gitment","slug":"gitment","permalink":"http://kinglion580.github.io/tags/gitment/"},{"name":"valine","slug":"valine","permalink":"http://kinglion580.github.io/tags/valine/"}]},{"title":"stdout_stderr","date":"2018-01-13T08:06:08.913Z","path":"2018/01/13/stdout_stderr/","text":"determine if output is stdout or stderrsolution redireciton standard input: 0 standard output: 1 standard error: 2 print STDERR in red1bash func 2&gt; &gt;(while read line; do echo -e \"\\e[01;31m$line\\e[0m\" &gt;&amp;2;done) 实验楼 references determine if output is stdout or stderr bash:print stderr in red color","tags":[{"name":"stdout","slug":"stdout","permalink":"http://kinglion580.github.io/tags/stdout/"},{"name":"stderr","slug":"stderr","permalink":"http://kinglion580.github.io/tags/stderr/"}]},{"title":"sed_markdown","date":"2018-01-13T08:06:08.912Z","path":"2018/01/13/sed_markdown/","text":"questionoptimize markdown documents with sedintroduceYou are the document inspector of the shiyanlou, need to check document format every day, a document found in different marks appear blank between too much (provisions require only a blank document appeared in 2, 3 cases), and all the image formats are written into the link, need you use this document to quickly repair Sed. For example, a document does not regulate instances and link errors:123456789## title one## Title Two## Title Three[picture-1] (https://www.shiyanlou.com/test.png) Title Two and Title Three require only one empty line directly. you should execute the Sed script in this way:1Sed -f /home/shiyanlou/fix-format.sed document After execution, the document is turned into:1234567## title one## Title Two## Title Three[picture-1] (https://www.shiyanlou.com/test.png) target The script path must be placed in the /home/shiyanlou/fix-format.sed The way to call is: sed -f /home/shiyanlou/fix-format.sed document Delete extra repeat blank lines in a document revising the format of the picture link Hint sed matching empty lines the hints of the picture link are all in [picture-xxx] format, and the suffix of the address is.Png or.Jpg test document download link: http://labfile.oss.aliyuncs.com/courses/980/test-document.md Knowledge point regular expression Sed keypoint delete rows retain only one line 1234/^$/&#123; N /^\\n$/D&#125; replace 1s/\\[picture/\\!\\[picture/ Note that the escape character references my-knowledge-sed","tags":[{"name":"sed","slug":"sed","permalink":"http://kinglion580.github.io/tags/sed/"}]},{"title":"monitor_mysql","date":"2018-01-13T08:06:08.911Z","path":"2018/01/13/monitor_mysql/","text":"questionmonitor service with bashintroduceOn the server, our services may be hung up for a variety of reasons, such as mongodb Out of memory, and the system is kill, resulting in the service can not work properly. So we need a simple monitoring script check_service.sh to view the status of our service in real time. If the service state is stopped, we can try to restart the service automatically. The script can accept a parameter, which is the name of the service. The name of the service can use the service command to view, start and stop the state. For example, check the status of the MySQL service.12$bash /home/shiyanlou/check_service.sh mysqlIs Running If the MySQL service is not running, the MySQL service is started and the following output information is printed:12$bash /home/shiyanlou/check_service.sh mysqlRestarting If the service does not exist, the error information is output:12$bash /home/shiyanlou/check_service.sh notfoundserviceError: Service Not Found target The script is named check_serive.sh, and the path must be /home/shiyanlou/check_service.sh The script can accept a parameter, the parameter is the name of the service, and the check_service.sh service name can be called in this way If the service is running “is Running”, if the service is stopped, the service is started, and if the service does not exist, output error information /home/shiyanlou/check_service.sh mysql is put into crontab once a day, which can ensure that MySQL service can be restarted when it is hung up, and we need to manually start cron service. Hint You can use sudo service xxx start/status/stop for service management Use of command line position parameters Service status information use can be judged by grep Knowledge point Bash process control The control of service and process Crontab keypoint123456789101112#!/bin/bashif [ `ps -ef|grep -v grep|grep $1|wc -l` -gt 3 ];then echo \"is Running\"else sudo service $1 start if [ `ps -ef|grep -v grep|grep $1|wc -l` -gt 2 ];then echo \"Restarting\" else echo \"Error:Service Not Found\" fifi 123456789101112#!/bin/bashif [ `netstat -at|grep $1|wc -l` -gt 0 ];then echo \"is Running\"else sudo service $1 start if [ `netstat -at|grep $1|wc -l` -gt 0 ];then echo \"Restarting\" else echo \"Error:Service Not Found\" fifi view the process ps -ef grep -v exclude the grep process wc -l count row num netstat -at|grep mysql pstree show the derived relation between the proceses in a tree diagram way start crontab sudo service rsyslog start sudo cron -f &amp;","tags":[{"name":"crontab","slug":"crontab","permalink":"http://kinglion580.github.io/tags/crontab/"},{"name":"ps","slug":"ps","permalink":"http://kinglion580.github.io/tags/ps/"},{"name":"netstat","slug":"netstat","permalink":"http://kinglion580.github.io/tags/netstat/"}]},{"title":"Hello World","date":"2018-01-13T08:06:08.911Z","path":"2018/01/13/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hello","slug":"hello","permalink":"http://kinglion580.github.io/tags/hello/"},{"name":"world","slug":"world","permalink":"http://kinglion580.github.io/tags/world/"}]},{"title":"github","date":"2018-01-13T08:06:08.910Z","path":"2018/01/13/github/","text":"目录 Table of Contents generated with DocToc 推荐阅读 Releases 关于 releases 限制 创建 release 从 tag 创建 发布本地的包 Tag 列出标签 创建标签 附注标签 轻量标签 推送标签 单个 多个 Wikis 关于 wikis 通过在线界面添加维基页面 搜索 issue 从 milestones 新建 issue 从 projects 新建 issue milestones 创建一个 milestones 将 issue 和 milestones 关联 Projects 关于 Projects 自动将 issue 链接到 to do 那列 推荐阅读 git中文文档 github help create releases link to release 打标签 Releases关于 releases发行版是 GitHub 为用户打包和提供软件的方式。releases 里面可以放不同版本的软件，用户可以从中下载。使用 releases，您可以提供二进制文件的链接以及描述更改的发行说明。 img 限制我们不会限制二进制发布文件的总大小，也不会限制用于发布它们的带宽。但是，每个文件都必须小于 2 GB。 创建 releasecreate releases 创建 release 前要创建 tag。有下面两种创建方式： 从 tag 创建 发布一个本地的包 从 tag 创建link to release 步骤： 创建 tag ：这一步完成过后在 releases 页面会出现一个 release 点击 releases 页面的版本号 跳转到的页面点 edit，填好各种信息 update release 过后 发布本地的包release 基础就是 tag ，所以要在有 tag 的情况下。发布的时候要关联 tag 在GitHub上，导航到存储库的主页面。 在您的存储库名称下，单击 releases。 点击 Draft a new release。 为您的版本键入一个版本号。版本基于Git标签。我们建议命名符合语义版本的标签。 选择一个包含您想要发布的项目的分支。通常情况下，master 除非您发布测试版软件，否则您需要针对您的分支进行发布。 Select a branch that contains the project you want to release. Usually, you’ll want to release against your master branch, unless you’re releasing beta software. 输入描述您的版本的标题和描述。 如果您想将二进制文件与发行版一起包括在内，例如编译后的程序，请在二进制文件夹中手动拖放或选择文件。 If you’d like to include binary files along with your release, such as compiled programs, drag and drop or select files manually in the binaries box. 如果版本不稳定，请选择“ 这是预发行版”，以通知用户尚未准备好生产。 If the release is unstable, select This is a pre-release to notify users that it’s not ready for production. 如果您准备公布您的版本，请点击发布版本。否则，请单击保存草稿以稍后处理。 If you’re ready to publicize your release, click Publish release. Otherwise, click Save draft to work on it later. Tag像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。 列出标签 git tag 创建 git tag -a [tagname] -m &#39;[tag description]&#39; 推送 git push origin [tagname] git push origin --tags 这样创建过后会自动生成一个 release 列出标签1$ git tag 创建标签Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。 一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。 然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。 附注标签运行 tag 命令时指定 -a 选项： 123$ git tag -a v0.1 -m 'my version 0.1'$ git tagv0.1 -m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。 通过使用 git show 命令可以看到标签信息与对应的提交信息： 123456789101112131415161718192021$ git showcommit ad204d47e2bc887acac78c1027f18622bcff34d4 (HEAD -&gt; source, tag: v0.1, origin/source, origin/HEAD)Author: kinglion580 &lt;1609019405@qq.com&gt;Date: Tue Jan 9 20:45:02 2018 +0800 fix deploydiff --git a/_config.yml b/_config.ymlindex 959ad9f..7f8d6c5 100644--- a/_config.yml+++ b/_config.yml@@ -76,9 +76,10 @@ theme: indigo # Deployment ## Docs: https://hexo.io/docs/deployment.html+## repo: https://github.com/kinglion580/kinglion580.github.io.git deploy: type: git- repo: https://github.com/kinglion580/kinglion580.github.io.git+ repo: git@github.com:kinglion580/kinglion580.github.io.git branch: master 输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。 轻量标签另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字： 123$ git tag v1.4-lw$ git tagv1.4-lw 这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息： 123456$ git show v1.4-lwcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 推送标签单个git push origin [tagname] 例如： 1$ git push origin v0.1 多个git push origin --tags 如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。 1234567$ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag] v1.4 -&gt; v1.4 * [new tag] v1.4-lw -&gt; v1.4-lw 注意：标签和分支概念不一样，标签并不能像分支一i样来回移动。不能真的被检出。 Wikis关于 wikis正如编写好的代码和优秀的测试很重要，优秀的文档可以帮助其他人使用和扩展您的项目。 每个GitHub存储库都配备了一个托管文档的部分，称为wiki。 Just as writing good code and great tests are important, excellent documentation helps others use and extend your project. Every GitHub repository comes equipped with a section for hosting documentation, called a wiki. 主要的wiki展示 GitHub Wiki是您的存储库中的一个地方，您可以共享关于您的项目的长篇内容，例如如何使用它，如何设计它，如何设计其核心原则，等等。README旨在快速引导读者了解您的项目可以做什么，而维基可以用来提供额外的文档。 使用wiki，您可以像GitHub上的其他地方一样编写内容。我们使用我们的开源Markup库将不同的格式转换成HTML，所以当您制作维基页面时，您可以选择使用Markdown，RST，Textile或任何其他支持的格式编写。 Wiki可以直接在GitHub上进行编辑，也可以离线使用文本编辑器，只需推送更改即可。维基通过设计协作。默认情况下，只有存储库上的协作者可以对Wiki进行更改，但是可以将其配置为对公共存储库中的所有用户启用。 GitHub Wikis are a place in your repository where you can share long-form content about your project, such as how to use it, how it’s been designed, manifestos on its core principles, and so on. Whereas a README is intended to quickly orient readers as to what your project can do, wikis can be used to provide additional documentation. With wikis, you can write content just like everywhere else on GitHub. We use our open-source Markup library to convert different formats into HTML, so you can choose to write in Markdown, RST, Textile, or any other supported format when you craft wiki pages. Wikis can be edited directly on GitHub, or you can work with a text editor offline and simply push your changes. Wikis are collaborative by design. By default, only collaborators on your repository can make changes to wikis, but you can configure this to be enabled for all users on public repositories. 通过在线界面添加维基页面您可以使用我们的Web界面将新的wiki页面直接添加到您的存储库。 在GitHub上，导航到存储库的主页面。 在您的存储库名称下，单击 Wiki。 从顶部菜单栏中，单击新建页面。 Wiki页面可以包含GitHub支持的任何标记。默认选择是Markdown，但是您可以使用“编辑模式”下拉菜单切换到不同的标记语言。 使用文本编辑器来添加页面的内容。您还可以使用顶部的维基工具栏使用图形化的所见即所得编辑器输入文本 。 输入描述您添加的新文件的提交消息。 要将更改提交到wiki，请单击保存页面。 搜索https://help.github.com/articles/searching-wikis/ You can search wikis by using search qualifiers in any combination to narrow your search results. Tips: For a list of search syntaxes that you can add to any search qualifier to further improve your results, see “Understanding the search syntax“. Use quotations around multi-word search terms. For example, if you want to search for issues with the label “In progress,” you’d search for label:&quot;in progress&quot;. Search is not case sensitive. Search within a user or organization’s repositories To find wiki pages from all repositories owned by a certain user or organization, use the user or orgqualifier. To find wiki pages from a specific repository, use the repo qualifier. Qualifier Example user:*USERNAME* user:defunkt matches wiki pages from repositories owned by @defunkt. org:*ORGNAME* org:github matches wikis in repositories owned by the GitHub organization. repo:*USERNAME/REPOSITORY* repo:defunkt/gibberish matches wiki pages from @defunkt’s “gibberish” repository. Search within a wiki page title or body text The in qualifier limits the search to the wiki page title or body text. Without the qualifier, both the title and body text are searched. Qualifier Example in:title usage in:title matches wiki page titles with the word “usage.” in:body installation in:body matches wiki pages with the word “installation” in their main body text. Search by last updated date The updated qualifier matches wiki pages that were last updated within the specified date range. Dates support greater than, less than, and range qualifiers. Qualifier Example updated:*YYYY-MM-DD* usage updated:&gt;2016-01-01 matches wiki pages with the word “usage” that were last updated after 2016-01-01. issue issue 的种类用 label 标记 issue 的处理进度用 milestones 标记 更高端的管理方式，使用 Projects 从 milestones 新建 issue 新建一个 milestones 在创建的 milestones 里点击 new issue ，添加一个 issue。 相关信息填写好后 submit 就可以了 从 projects 新建 issue移步至 projects milestones您可以使用里程碑跟踪存储库中的问题组或进程请求的进度。 s里程碑里可以和问题以及请求相关联。 创建一个 milestones 点击 issues-》milestones 点击 new milestone 填写相关信息 填写好后提交 将 issue 和 milestones 关联进入到 issue 界面可以选 issue 属于哪个 milestone 不用点击 commit 在里程碑里可以查看到包括的 issue 可以鼠标按住勾选框左边的地方拖动调整优先顺序 可以点击最上面的勾选框对包含的 issue 筛选 解决一个 issue 就 close 掉 issue ，在里程碑的界面会显示处理进度 Projects关于 Projectsprojects 相当于融合了 issue 的 label 和 milestone。在一个界面就行操作。 projects 提供项目管理功能。可以点击 Projects 进入管理界面，点击添加会让你输入项目名，下面的选项可以选择 auto ，也就是自动套用有的模板，就出现下面的界面。 下图框选部分相当于是一个 milestone。 下图这个东西叫看板。里面的列相当于 label。 可以把右边列的 issue 拖动到左边的列中去，也可以添加一个 card 转换成 issue。 上面显示的是进度。 在 issue 界面中被 close 的 issue 会自动出现在 done 那列中。 只用拖动和一些简单的操作就可以管理进度，非常方便，而 milestone 的方式是采用勾选框勾选。 projects 里面可以增加列，也就是说可以采用添加列的方式实现一些其他的功能，比如说添加列来归类 issue 的种类。 自动将 issue 链接到 to do 那列 点击 Manage automation 勾选 第一个勾选框意思就是新添加的 issue 和请求自动移动到这里 第二个就是重新打开的 issue 和请求自动移动到这里 连接 在 projects 页面就可以看到 issue 自动出现在 to do 那列","tags":[{"name":"releases","slug":"releases","permalink":"http://kinglion580.github.io/tags/releases/"},{"name":"tags","slug":"tags","permalink":"http://kinglion580.github.io/tags/tags/"},{"name":"wikis","slug":"wikis","permalink":"http://kinglion580.github.io/tags/wikis/"},{"name":"issues","slug":"issues","permalink":"http://kinglion580.github.io/tags/issues/"},{"name":"milestones","slug":"milestones","permalink":"http://kinglion580.github.io/tags/milestones/"},{"name":"projects","slug":"projects","permalink":"http://kinglion580.github.io/tags/projects/"}]},{"title":"crontab","date":"2018-01-13T08:06:08.909Z","path":"2018/01/13/crontab/","text":"questionPeriodically pack a backup logintroduceYou are the server administrator of the experiment building, and you need to back up the log files in the /var/log directory every day. After the backup is packed and compressed for a long time, the file name is stored in the format of the year-month-day.Tar.gz. For example, the file backed up in November 1, 2017 is 2017-11-01.tar.gz, and the files after the backup are stored in the /home/shiyanlou/backup directory. Note that you need to use the method of incremental backup of the tar command to make a backup. target Add planning tasks for shiyanlou users Every day at 3 a.m., back up the /var/log directory to the /home/shiyanlou/backup/year-month-day.Tar.gz file, and note that it is an incremental backup. Backup file naming format is year-month-day.Tar.gz Write to crontab with a command, do not write the scriptHint Crontab sets a tar command for an incremental backup of the specified time. Knowledge pointDate formatted output stringCrontab set planning tasksTar command incremental backup mode keypoint 0 3 * tar -cvf /home/shiyanlou/backup/$(date +\\%Y-\\%m-\\%d).tar.gz -g /var/log tar.gz 0 3 \\%Y\\%m\\%d\\%H\\%M\\%S how to start cron12sudo service rsyslog startsudo cron -f &amp; check whether cron is started123ps aux|grep cronorpgrep cron edit1crontab -e list1crontab -l remove1crontab -r","tags":[{"name":"crontab","slug":"crontab","permalink":"http://kinglion580.github.io/tags/crontab/"}]},{"title":"find_and_pack","date":"2018-01-13T08:06:08.909Z","path":"2018/01/13/find_and_pack/","text":"questionsFind and package the specified filesintroduceThe challenges you need to find the /etc directory to meet the needs of the file, then, package and compress the file into a tar.gz package. First, create a folder /home/shiyanlou/backup, and all the files that need to be packaged will be copied to this directory. Then, copy all the files larger than 12K to the /home/shiyanlou/backup directory in the /etc directory of the lab building, and we need to keep the directory structure. For example, the /etc/apt/trusted.gpg file is 14K, and it will be copied to the /home/shiyanlou/backup/etc/apt/trusted.gpg path position. Notice that there are many files in the subfolder under the /etc directory that are more than 12K and need to be copied. After the copy is completed, the /home/shiyanlou/backup is packaged and compressed, and the generated packet backup.tar.gz is placed under the /tmp/backup.tar.gz path. Click to submit the result after the completion of the above task. target The compressed packet backup.tar.gz is placed under the /tmp/backup.tar.gz path The compressed package backup.tar.gz contains all the files larger than 12K under the /etc directory, regardless of whether the shiyanlou user has access to the file or not. Please do not use soft links, such as the need to complete the copy of the file past. Hint find, copy, pack, compress Knowledge point Linux file and directory operation Linux file lookup operation Tar command package Gzip command compression keypointThe find command looks up some files and copies them to the specified directory 12&gt; sudo find /etc -size +12k -exec cp --parents &#123;&#125; backup \\;&gt; &gt; exec cp --parents references find,cp,exec-sample find,cp,exec-detail Preserving directory structure application instances when CP copies tools linux command search","tags":[{"name":"find","slug":"find","permalink":"http://kinglion580.github.io/tags/find/"},{"name":"exec","slug":"exec","permalink":"http://kinglion580.github.io/tags/exec/"},{"name":"cp","slug":"cp","permalink":"http://kinglion580.github.io/tags/cp/"}]}]